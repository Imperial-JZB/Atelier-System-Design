-- DROP DATABASE IF EXISTS qanda WITH (FORCE);

-- CREATE DATABASE qanda;

\c qanda

DROP TABLE IF EXISTS products, questions, answers, answer_photos;

CREATE TABLE products(
  product_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  product_name VARCHAR(30) NOT NULL,
  slogan VARCHAR(300),
  description VARCHAR(500),
  category VARCHAR(20),
  default_price INT
);

CREATE TABLE questions(
  question_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  product_id INT NOT NULL,
  question_body TEXT NOT NULL,
  question_date BIGINT,
  asker_name VARCHAR(50),
  asker_email VARCHAR(50),
  reported INT DEFAULT 0,
  question_helpfulness INT DEFAULT 0,
  FOREIGN KEY(product_id) references products(product_id)
);

CREATE TABLE answers(
  answer_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  question_id INT NOT NULL,
  body TEXT,
  date BIGINT,
  answerer_name VARCHAR(50),
  answerer_email VARCHAR(50),
  reported INT DEFAULT 0,
  helpfulness INT DEFAULT 0,
  FOREIGN KEY(question_id) references questions(question_id)
);

CREATE TABLE answer_photos(
  answer_photos_id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  url VARCHAR(300),
  answer_id INT NOT NULL,
  FOREIGN KEY(answer_id) references answers(answer_id)
);


COPY products(product_id, product_name, slogan, description, category, default_price) FROM '/Users/brianbui/Desktop/HR Sprints/SDC/data/product.csv' DELIMITER ',' CSV header;

COPY questions(question_id, product_id , question_body, question_date, asker_name, asker_email, reported, question_helpfulness) FROM '/Users/brianbui/Desktop/HR Sprints/SDC/data/questions.csv' DELIMITER ',' CSV header;

COPY answers(answer_id, question_id , body, date, answerer_name, answerer_email, reported, helpfulness) FROM '/Users/brianbui/Desktop/HR Sprints/SDC/data/answers.csv' DELIMITER ',' CSV header;

COPY answer_photos(answer_photos_id, answer_id, url) FROM '/Users/brianbui/Desktop/HR Sprints/SDC/data/answers_photos.csv' DELIMITER ',' CSV header;


-- After Copying in all data
-- ALTER TABLE review
-- ALTER COLUMN review_date TYPE TIMESTAMPTZ
-- USING (to_timestamp(review_date::decimal/1000));

CREATE INDEX idx_product_id_questions ON questions(product_id);
CREATE INDEX idx_question_id_answers ON answers(question_id);
CREATE INDEX idx_answer_id_answer_photos ON answer_photos(answer_id);
CREATE INDEX idx_reported_questions ON questions(reported);
CREATE INDEX idx_reported_answers ON answers(reported);

-- IMPLEMENTING MATERIALIZED VIEW TABLE QUESTIONS QUERY
CREATE MATERIALIZED VIEW mv_product
AS
 SELECT q.product_id,
    (
      SELECT json_agg (
      json_build_object (
      'question_id', q.question_id,
      'question_body', q.question_body,
      'question_date',(to_char(to_timestamp(q.question_date / 1000), 'yyyy-MM-dd"T"00:00:00.000Z')),
      'asker_name', q.asker_name,
      'question_helpfulness', q.question_helpfulness,
      'reported', q.reported,
      'answers', (SELECT json_object_agg(a.answer_id,
        json_build_object (
          'id', a.answer_id,
          'body', a.body,
          'date', (to_char(to_timestamp(a.date / 1000), 'yyyy-MM-dd"T"00:00:00.000Z')),
          'answerer_name', a.answerer_name,
          'helpfulness', a.helpfulness,
          'photos', (SELECT array_agg (ap.url)
        FROM answer_photos AS ap
        WHERE answer_id = a.answer_id ))) as answers
        FROM answers AS a
        WHERE question_id = q.question_id AND reported < 1
        )
       )
      )) as results
      FROM questions AS q
      GROUP BY q.product_id
WITH DATA;

CREATE UNIQUE INDEX mv_product_idx ON mv_product(product_id);

-- CREATE OR REPLACE FUNCTION tg_refresh_mv_product()
-- RETURNS trigger LANGUAGE plpgsql AS $$
-- BEGIN
--   REFRESH MATERIALIZED VIEW CONCURRENTLY mv_product;
--   RETURN NULL;
-- END;
-- $$;

-- CREATE TRIGGER tg_refresh_mv_product AFTER INSERT OR UPDATE OR DELETE
-- ON questions
-- FOR EACH STATEMENT EXECUTE PROCEDURE tg_refresh_mv_product();

-- CREATE TRIGGER tg_refresh_mv_product AFTER INSERT OR UPDATE OR DELETE
-- ON answers
-- FOR EACH STATEMENT EXECUTE PROCEDURE tg_refresh_mv_product();


-- IMPLEMENTING MATERIALIZED VIEW TABLE ANSWERS QUERY
CREATE MATERIALIZED VIEW mv_question
AS
  SELECT a.question_id,
    (SELECT json_agg (
      json_build_object (
        'answer_id', a.answer_id,
        'body', a.body,
        'date', (to_char(to_timestamp(a.date / 1000), 'yyyy-MM-dd"T"00:00:00.000Z')),
        'answerer_name', a.answerer_name,
        'helpfulness', a.helpfulness,
        'photos', (SELECT json_agg (
          json_build_object (
            'id', ap.answer_photos_id,
            'url', ap.url
          ))
          FROM answer_photos as ap
          WHERE answer_id = a.answer_id AND reported < 1
            )
          )
        )) as results
    FROM answers AS a
    GROUP BY a.question_id
WITH DATA;

CREATE UNIQUE INDEX mv_question_idx ON mv_question(question_id);

-- CREATE OR REPLACE FUNCTION tg_refresh_mv_question()
-- RETURNS trigger LANGUAGE plpgsql AS $$
-- BEGIN
--   REFRESH MATERIALIZED VIEW CONCURRENTLY mv_question;
--   RETURN NULL;
-- END;
-- $$;

-- CREATE TRIGGER tg_refresh_mv_question AFTER INSERT OR UPDATE OR DELETE
-- ON questions
-- FOR EACH STATEMENT EXECUTE PROCEDURE tg_refresh_mv_question();

-- CREATE TRIGGER tg_refresh_mv_question AFTER INSERT OR UPDATE OR DELETE
-- ON answers
-- FOR EACH STATEMENT EXECUTE PROCEDURE tg_refresh_mv_question();

-- Questions, do we need to do a periodic update?
-- Do we need to set triggers on product_id updates?
-- Currently we're only doing post on questions and answers so we just set triggers there